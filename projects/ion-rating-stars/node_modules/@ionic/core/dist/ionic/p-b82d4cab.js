/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
import{d as e}from"./p-7b30edcc.js";import{MENU_BACK_BUTTON_PRIORITY as t}from"./p-ecceeb90.js";import{p as n}from"./p-06fee233.js";import{c as r}from"./p-b51e4004.js";import{b as s}from"./p-0574e87e.js";import{c as a}from"./p-c7e16491.js";const o=e=>a().duration(e?400:300),i=e=>{let t,n;const r=e.width+8,i=a(),u=a();e.isEndSide?(t=r+"px",n="0px"):(t=-r+"px",n="0px"),i.addElement(e.menuInnerEl).fromTo("transform",`translateX(${t})`,`translateX(${n})`);const c="ios"===s(e),p=c?.2:.25;return u.addElement(e.backdropEl).fromTo("opacity",.01,p),o(c).addAnimation([i,u])},u=e=>{let t,n;const r=s(e),i=e.width;e.isEndSide?(t=-i+"px",n=i+"px"):(t=i+"px",n=-i+"px");const u=a().addElement(e.menuInnerEl).fromTo("transform",`translateX(${n})`,"translateX(0px)"),c=a().addElement(e.contentEl).fromTo("transform","translateX(0px)",`translateX(${t})`),p=a().addElement(e.backdropEl).fromTo("opacity",.01,.32);return o("ios"===r).addAnimation([u,c,p])},c=e=>{const t=s(e),n=e.width*(e.isEndSide?-1:1)+"px",r=a().addElement(e.contentEl).fromTo("transform","translateX(0px)",`translateX(${n})`);return o("ios"===t).addAnimation(r)},p=(()=>{const s=new Map,a=[],o=async(e,t=!1)=>{if(await d(),"start"===e||"end"===e){const r=a.filter((t=>t.side===e&&!t.disabled));if(r.length>=1)return r.length>1&&t&&n(`menuController queried for a menu on the "${e}" side, but ${r.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,r.map((e=>e.el))),r[0].el;const s=a.filter((t=>t.side===e));if(s.length>=1)return s.length>1&&t&&n(`menuController queried for a menu on the "${e}" side, but ${s.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,s.map((e=>e.el))),s[0].el}else if(null!=e)return w((t=>t.menuId===e));return w((e=>!e.disabled))||(a.length>0?a[0].el:void 0)},p=async()=>(await d(),f()),m=(e,t)=>{s.set(e,t)},f=()=>w((e=>e._isOpen)),l=()=>a.some((e=>e.isAnimating)),w=e=>{const t=a.find(e);if(void 0!==t)return t.el},d=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((e=>new Promise((t=>r(e,t))))));return m("reveal",c),m("push",u),m("overlay",i),null==e||e.addEventListener("ionBackButton",(e=>{const n=f();n&&e.detail.register(t,(()=>n.close()))})),{registerAnimation:m,get:o,getMenus:async()=>(await d(),a.map((e=>e.el))),getOpen:p,isEnabled:async e=>{const t=await o(e);return!!t&&!t.disabled},swipeGesture:async(e,t)=>{const n=await o(t);return n&&(n.swipeGesture=e),n},isAnimating:async()=>(await d(),l()),isOpen:async e=>{if(null!=e){const t=await o(e);return void 0!==t&&t.isOpen()}return void 0!==await p()},enable:async(e,t)=>{const n=await o(t);return n&&(n.disabled=!e),n},toggle:async e=>{const t=await o(e,!0);return!!t&&t.toggle()},close:async e=>{const t=await(void 0!==e?o(e,!0):p());return void 0!==t&&t.close()},open:async e=>{const t=await o(e,!0);return!!t&&t.open()},_getOpenSync:f,_createAnimation:(e,t)=>{const n=s.get(e);if(!n)throw new Error("animation not registered");return n(t)},_register:e=>{a.indexOf(e)<0&&a.push(e)},_unregister:e=>{const t=a.indexOf(e);t>-1&&a.splice(t,1)},_setOpen:async(e,t,n,r)=>{if(l())return!1;if(t){const t=await p();t&&e.el!==t&&await t.setOpen(!1,!1)}return e._setOpen(t,n,r)}}})();export{p as m}