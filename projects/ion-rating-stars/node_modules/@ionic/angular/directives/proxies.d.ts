import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone } from '@angular/core';
import { Components } from '@ionic/core';
import type { AccordionGroupChangeEventDetail as IIonAccordionGroupAccordionGroupChangeEventDetail } from '@ionic/core';
import type { OverlayEventDetail as IIonActionSheetOverlayEventDetail } from '@ionic/core';
import type { OverlayEventDetail as IIonAlertOverlayEventDetail } from '@ionic/core';
import type { BreadcrumbCollapsedClickEventDetail as IIonBreadcrumbsBreadcrumbCollapsedClickEventDetail } from '@ionic/core';
import type { CheckboxChangeEventDetail as IIonCheckboxCheckboxChangeEventDetail } from '@ionic/core';
import type { ScrollBaseDetail as IIonContentScrollBaseDetail } from '@ionic/core';
import type { ScrollDetail as IIonContentScrollDetail } from '@ionic/core';
import type { DatetimeChangeEventDetail as IIonDatetimeDatetimeChangeEventDetail } from '@ionic/core';
import type { InputInputEventDetail as IIonInputInputInputEventDetail } from '@ionic/core';
import type { InputChangeEventDetail as IIonInputInputChangeEventDetail } from '@ionic/core';
import type { OverlayEventDetail as IIonLoadingOverlayEventDetail } from '@ionic/core';
import type { MenuCloseEventDetail as IIonMenuMenuCloseEventDetail } from '@ionic/core';
import type { PickerColumnChangeEventDetail as IIonPickerColumnPickerColumnChangeEventDetail } from '@ionic/core';
import type { OverlayEventDetail as IIonPickerLegacyOverlayEventDetail } from '@ionic/core';
import type { RadioGroupChangeEventDetail as IIonRadioGroupRadioGroupChangeEventDetail } from '@ionic/core';
import type { RangeChangeEventDetail as IIonRangeRangeChangeEventDetail } from '@ionic/core';
import type { RangeKnobMoveStartEventDetail as IIonRangeRangeKnobMoveStartEventDetail } from '@ionic/core';
import type { RangeKnobMoveEndEventDetail as IIonRangeRangeKnobMoveEndEventDetail } from '@ionic/core';
import type { RefresherEventDetail as IIonRefresherRefresherEventDetail } from '@ionic/core';
import type { ItemReorderEventDetail as IIonReorderGroupItemReorderEventDetail } from '@ionic/core';
import type { SearchbarInputEventDetail as IIonSearchbarSearchbarInputEventDetail } from '@ionic/core';
import type { SearchbarChangeEventDetail as IIonSearchbarSearchbarChangeEventDetail } from '@ionic/core';
import type { SegmentChangeEventDetail as IIonSegmentSegmentChangeEventDetail } from '@ionic/core';
import type { SegmentViewScrollEvent as IIonSegmentViewSegmentViewScrollEvent } from '@ionic/core';
import type { SelectChangeEventDetail as IIonSelectSelectChangeEventDetail } from '@ionic/core';
import type { TextareaChangeEventDetail as IIonTextareaTextareaChangeEventDetail } from '@ionic/core';
import type { TextareaInputEventDetail as IIonTextareaTextareaInputEventDetail } from '@ionic/core';
import type { OverlayEventDetail as IIonToastOverlayEventDetail } from '@ionic/core';
import type { ToggleChangeEventDetail as IIonToggleToggleChangeEventDetail } from '@ionic/core';
import * as i0 from "@angular/core";
export declare class IonAccordion {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAccordion, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAccordion, "ion-accordion", never, { "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "toggleIcon": { "alias": "toggleIcon"; "required": false; }; "toggleIconSlot": { "alias": "toggleIconSlot"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonAccordion extends Components.IonAccordion {
}
export declare class IonAccordionGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAccordionGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAccordionGroup, "ion-accordion-group", never, { "animated": { "alias": "animated"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "expand": { "alias": "expand"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonAccordionGroup extends Components.IonAccordionGroup {
    /**
     * Emitted when the value property has changed as a result of a user action such as a click.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonAccordionGroupAccordionGroupChangeEventDetail>>;
}
export declare class IonActionSheet {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonActionSheet, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonActionSheet, "ion-action-sheet", never, { "animated": { "alias": "animated"; "required": false; }; "backdropDismiss": { "alias": "backdropDismiss"; "required": false; }; "buttons": { "alias": "buttons"; "required": false; }; "cssClass": { "alias": "cssClass"; "required": false; }; "enterAnimation": { "alias": "enterAnimation"; "required": false; }; "header": { "alias": "header"; "required": false; }; "htmlAttributes": { "alias": "htmlAttributes"; "required": false; }; "isOpen": { "alias": "isOpen"; "required": false; }; "keyboardClose": { "alias": "keyboardClose"; "required": false; }; "leaveAnimation": { "alias": "leaveAnimation"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "subHeader": { "alias": "subHeader"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; "trigger": { "alias": "trigger"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonActionSheet extends Components.IonActionSheet {
    /**
     * Emitted after the action sheet has presented.
     */
    ionActionSheetDidPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the action sheet has presented.
     */
    ionActionSheetWillPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the action sheet has dismissed.
     */
    ionActionSheetWillDismiss: EventEmitter<CustomEvent<IIonActionSheetOverlayEventDetail>>;
    /**
     * Emitted after the action sheet has dismissed.
     */
    ionActionSheetDidDismiss: EventEmitter<CustomEvent<IIonActionSheetOverlayEventDetail>>;
    /**
     * Emitted after the action sheet has presented.
  Shorthand for ionActionSheetWillDismiss.
     */
    didPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the action sheet has presented.
  Shorthand for ionActionSheetWillPresent.
     */
    willPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the action sheet has dismissed.
  Shorthand for ionActionSheetWillDismiss.
     */
    willDismiss: EventEmitter<CustomEvent<IIonActionSheetOverlayEventDetail>>;
    /**
     * Emitted after the action sheet has dismissed.
  Shorthand for ionActionSheetDidDismiss.
     */
    didDismiss: EventEmitter<CustomEvent<IIonActionSheetOverlayEventDetail>>;
}
export declare class IonAlert {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAlert, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAlert, "ion-alert", never, { "animated": { "alias": "animated"; "required": false; }; "backdropDismiss": { "alias": "backdropDismiss"; "required": false; }; "buttons": { "alias": "buttons"; "required": false; }; "cssClass": { "alias": "cssClass"; "required": false; }; "enterAnimation": { "alias": "enterAnimation"; "required": false; }; "header": { "alias": "header"; "required": false; }; "htmlAttributes": { "alias": "htmlAttributes"; "required": false; }; "inputs": { "alias": "inputs"; "required": false; }; "isOpen": { "alias": "isOpen"; "required": false; }; "keyboardClose": { "alias": "keyboardClose"; "required": false; }; "leaveAnimation": { "alias": "leaveAnimation"; "required": false; }; "message": { "alias": "message"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "subHeader": { "alias": "subHeader"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; "trigger": { "alias": "trigger"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonAlert extends Components.IonAlert {
    /**
     * Emitted after the alert has presented.
     */
    ionAlertDidPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the alert has presented.
     */
    ionAlertWillPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the alert has dismissed.
     */
    ionAlertWillDismiss: EventEmitter<CustomEvent<IIonAlertOverlayEventDetail>>;
    /**
     * Emitted after the alert has dismissed.
     */
    ionAlertDidDismiss: EventEmitter<CustomEvent<IIonAlertOverlayEventDetail>>;
    /**
     * Emitted after the alert has presented.
  Shorthand for ionAlertWillDismiss.
     */
    didPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the alert has presented.
  Shorthand for ionAlertWillPresent.
     */
    willPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the alert has dismissed.
  Shorthand for ionAlertWillDismiss.
     */
    willDismiss: EventEmitter<CustomEvent<IIonAlertOverlayEventDetail>>;
    /**
     * Emitted after the alert has dismissed.
  Shorthand for ionAlertDidDismiss.
     */
    didDismiss: EventEmitter<CustomEvent<IIonAlertOverlayEventDetail>>;
}
export declare class IonApp {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonApp, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonApp, "ion-app", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonApp extends Components.IonApp {
}
export declare class IonAvatar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAvatar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAvatar, "ion-avatar", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonAvatar extends Components.IonAvatar {
}
export declare class IonBackdrop {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBackdrop, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBackdrop, "ion-backdrop", never, { "stopPropagation": { "alias": "stopPropagation"; "required": false; }; "tappable": { "alias": "tappable"; "required": false; }; "visible": { "alias": "visible"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonBackdrop extends Components.IonBackdrop {
    /**
     * Emitted when the backdrop is tapped.
     */
    ionBackdropTap: EventEmitter<CustomEvent<void>>;
}
export declare class IonBadge {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBadge, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBadge, "ion-badge", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonBadge extends Components.IonBadge {
}
export declare class IonBreadcrumb {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBreadcrumb, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBreadcrumb, "ion-breadcrumb", never, { "active": { "alias": "active"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "href": { "alias": "href"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; "separator": { "alias": "separator"; "required": false; }; "target": { "alias": "target"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonBreadcrumb extends Components.IonBreadcrumb {
    /**
     * Emitted when the breadcrumb has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the breadcrumb loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonBreadcrumbs {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBreadcrumbs, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBreadcrumbs, "ion-breadcrumbs", never, { "color": { "alias": "color"; "required": false; }; "itemsAfterCollapse": { "alias": "itemsAfterCollapse"; "required": false; }; "itemsBeforeCollapse": { "alias": "itemsBeforeCollapse"; "required": false; }; "maxItems": { "alias": "maxItems"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonBreadcrumbs extends Components.IonBreadcrumbs {
    /**
     * Emitted when the collapsed indicator is clicked on.
     */
    ionCollapsedClick: EventEmitter<CustomEvent<IIonBreadcrumbsBreadcrumbCollapsedClickEventDetail>>;
}
export declare class IonButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonButton, "ion-button", never, { "buttonType": { "alias": "buttonType"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "expand": { "alias": "expand"; "required": false; }; "fill": { "alias": "fill"; "required": false; }; "form": { "alias": "form"; "required": false; }; "href": { "alias": "href"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; "shape": { "alias": "shape"; "required": false; }; "size": { "alias": "size"; "required": false; }; "strong": { "alias": "strong"; "required": false; }; "target": { "alias": "target"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonButton extends Components.IonButton {
    /**
     * Emitted when the button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonButtons {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonButtons, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonButtons, "ion-buttons", never, { "collapse": { "alias": "collapse"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonButtons extends Components.IonButtons {
}
export declare class IonCard {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCard, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCard, "ion-card", never, { "button": { "alias": "button"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "href": { "alias": "href"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; "target": { "alias": "target"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCard extends Components.IonCard {
}
export declare class IonCardContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardContent, "ion-card-content", never, { "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCardContent extends Components.IonCardContent {
}
export declare class IonCardHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardHeader, "ion-card-header", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCardHeader extends Components.IonCardHeader {
}
export declare class IonCardSubtitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardSubtitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardSubtitle, "ion-card-subtitle", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCardSubtitle extends Components.IonCardSubtitle {
}
export declare class IonCardTitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardTitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardTitle, "ion-card-title", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCardTitle extends Components.IonCardTitle {
}
export declare class IonCheckbox {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCheckbox, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCheckbox, "ion-checkbox", never, { "alignment": { "alias": "alignment"; "required": false; }; "checked": { "alias": "checked"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "indeterminate": { "alias": "indeterminate"; "required": false; }; "justify": { "alias": "justify"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCheckbox extends Components.IonCheckbox {
    /**
     * Emitted when the checked property has changed as a result of a user action such as a click.
  
  This event will not emit when programmatically setting the `checked` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonCheckboxCheckboxChangeEventDetail>>;
    /**
     * Emitted when the checkbox has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the checkbox loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonChip {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonChip, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonChip, "ion-chip", never, { "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "outline": { "alias": "outline"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonChip extends Components.IonChip {
}
export declare class IonCol {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCol, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCol, "ion-col", never, { "offset": { "alias": "offset"; "required": false; }; "offsetLg": { "alias": "offsetLg"; "required": false; }; "offsetMd": { "alias": "offsetMd"; "required": false; }; "offsetSm": { "alias": "offsetSm"; "required": false; }; "offsetXl": { "alias": "offsetXl"; "required": false; }; "offsetXs": { "alias": "offsetXs"; "required": false; }; "pull": { "alias": "pull"; "required": false; }; "pullLg": { "alias": "pullLg"; "required": false; }; "pullMd": { "alias": "pullMd"; "required": false; }; "pullSm": { "alias": "pullSm"; "required": false; }; "pullXl": { "alias": "pullXl"; "required": false; }; "pullXs": { "alias": "pullXs"; "required": false; }; "push": { "alias": "push"; "required": false; }; "pushLg": { "alias": "pushLg"; "required": false; }; "pushMd": { "alias": "pushMd"; "required": false; }; "pushSm": { "alias": "pushSm"; "required": false; }; "pushXl": { "alias": "pushXl"; "required": false; }; "pushXs": { "alias": "pushXs"; "required": false; }; "size": { "alias": "size"; "required": false; }; "sizeLg": { "alias": "sizeLg"; "required": false; }; "sizeMd": { "alias": "sizeMd"; "required": false; }; "sizeSm": { "alias": "sizeSm"; "required": false; }; "sizeXl": { "alias": "sizeXl"; "required": false; }; "sizeXs": { "alias": "sizeXs"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonCol extends Components.IonCol {
}
export declare class IonContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonContent, "ion-content", never, { "color": { "alias": "color"; "required": false; }; "fixedSlotPlacement": { "alias": "fixedSlotPlacement"; "required": false; }; "forceOverscroll": { "alias": "forceOverscroll"; "required": false; }; "fullscreen": { "alias": "fullscreen"; "required": false; }; "scrollEvents": { "alias": "scrollEvents"; "required": false; }; "scrollX": { "alias": "scrollX"; "required": false; }; "scrollY": { "alias": "scrollY"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonContent extends Components.IonContent {
    /**
     * Emitted when the scroll has started. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScrollStart: EventEmitter<CustomEvent<IIonContentScrollBaseDetail>>;
    /**
     * Emitted while scrolling. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScroll: EventEmitter<CustomEvent<IIonContentScrollDetail>>;
    /**
     * Emitted when the scroll has ended. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScrollEnd: EventEmitter<CustomEvent<IIonContentScrollBaseDetail>>;
}
export declare class IonDatetime {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonDatetime, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonDatetime, "ion-datetime", never, { "cancelText": { "alias": "cancelText"; "required": false; }; "clearText": { "alias": "clearText"; "required": false; }; "color": { "alias": "color"; "required": false; }; "dayValues": { "alias": "dayValues"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "doneText": { "alias": "doneText"; "required": false; }; "firstDayOfWeek": { "alias": "firstDayOfWeek"; "required": false; }; "formatOptions": { "alias": "formatOptions"; "required": false; }; "highlightedDates": { "alias": "highlightedDates"; "required": false; }; "hourCycle": { "alias": "hourCycle"; "required": false; }; "hourValues": { "alias": "hourValues"; "required": false; }; "isDateEnabled": { "alias": "isDateEnabled"; "required": false; }; "locale": { "alias": "locale"; "required": false; }; "max": { "alias": "max"; "required": false; }; "min": { "alias": "min"; "required": false; }; "minuteValues": { "alias": "minuteValues"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "monthValues": { "alias": "monthValues"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "name": { "alias": "name"; "required": false; }; "preferWheel": { "alias": "preferWheel"; "required": false; }; "presentation": { "alias": "presentation"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "showClearButton": { "alias": "showClearButton"; "required": false; }; "showDefaultButtons": { "alias": "showDefaultButtons"; "required": false; }; "showDefaultTimeLabel": { "alias": "showDefaultTimeLabel"; "required": false; }; "showDefaultTitle": { "alias": "showDefaultTitle"; "required": false; }; "size": { "alias": "size"; "required": false; }; "titleSelectedDatesFormatter": { "alias": "titleSelectedDatesFormatter"; "required": false; }; "value": { "alias": "value"; "required": false; }; "yearValues": { "alias": "yearValues"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonDatetime extends Components.IonDatetime {
    /**
     * Emitted when the datetime selection was cancelled.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the value (selected date) has changed.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonDatetimeDatetimeChangeEventDetail>>;
    /**
     * Emitted when the datetime has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the datetime loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonDatetimeButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonDatetimeButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonDatetimeButton, "ion-datetime-button", never, { "color": { "alias": "color"; "required": false; }; "datetime": { "alias": "datetime"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonDatetimeButton extends Components.IonDatetimeButton {
}
export declare class IonFab {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFab, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFab, "ion-fab", never, { "activated": { "alias": "activated"; "required": false; }; "edge": { "alias": "edge"; "required": false; }; "horizontal": { "alias": "horizontal"; "required": false; }; "vertical": { "alias": "vertical"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonFab extends Components.IonFab {
}
export declare class IonFabButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFabButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFabButton, "ion-fab-button", never, { "activated": { "alias": "activated"; "required": false; }; "closeIcon": { "alias": "closeIcon"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "href": { "alias": "href"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; "show": { "alias": "show"; "required": false; }; "size": { "alias": "size"; "required": false; }; "target": { "alias": "target"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonFabButton extends Components.IonFabButton {
    /**
     * Emitted when the button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonFabList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFabList, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFabList, "ion-fab-list", never, { "activated": { "alias": "activated"; "required": false; }; "side": { "alias": "side"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonFabList extends Components.IonFabList {
}
export declare class IonFooter {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFooter, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFooter, "ion-footer", never, { "collapse": { "alias": "collapse"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonFooter extends Components.IonFooter {
}
export declare class IonGrid {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonGrid, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonGrid, "ion-grid", never, { "fixed": { "alias": "fixed"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonGrid extends Components.IonGrid {
}
export declare class IonHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonHeader, "ion-header", never, { "collapse": { "alias": "collapse"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonHeader extends Components.IonHeader {
}
export declare class IonIcon {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonIcon, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonIcon, "ion-icon", never, { "color": { "alias": "color"; "required": false; }; "flipRtl": { "alias": "flipRtl"; "required": false; }; "icon": { "alias": "icon"; "required": false; }; "ios": { "alias": "ios"; "required": false; }; "lazy": { "alias": "lazy"; "required": false; }; "md": { "alias": "md"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "sanitize": { "alias": "sanitize"; "required": false; }; "size": { "alias": "size"; "required": false; }; "src": { "alias": "src"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonIcon extends Components.IonIcon {
}
export declare class IonImg {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonImg, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonImg, "ion-img", never, { "alt": { "alias": "alt"; "required": false; }; "src": { "alias": "src"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonImg extends Components.IonImg {
    /**
     * Emitted when the img src has been set
     */
    ionImgWillLoad: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the image has finished loading
     */
    ionImgDidLoad: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the img fails to load
     */
    ionError: EventEmitter<CustomEvent<void>>;
}
export declare class IonInfiniteScroll {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInfiniteScroll, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInfiniteScroll, "ion-infinite-scroll", never, { "disabled": { "alias": "disabled"; "required": false; }; "position": { "alias": "position"; "required": false; }; "threshold": { "alias": "threshold"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonInfiniteScroll extends Components.IonInfiniteScroll {
    /**
     * Emitted when the scroll reaches
  the threshold distance. From within your infinite handler,
  you must call the infinite scroll's `complete()` method when
  your async operation has completed.
     */
    ionInfinite: EventEmitter<CustomEvent<void>>;
}
export declare class IonInfiniteScrollContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInfiniteScrollContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInfiniteScrollContent, "ion-infinite-scroll-content", never, { "loadingSpinner": { "alias": "loadingSpinner"; "required": false; }; "loadingText": { "alias": "loadingText"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonInfiniteScrollContent extends Components.IonInfiniteScrollContent {
}
export declare class IonInput {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInput, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInput, "ion-input", never, { "autocapitalize": { "alias": "autocapitalize"; "required": false; }; "autocomplete": { "alias": "autocomplete"; "required": false; }; "autocorrect": { "alias": "autocorrect"; "required": false; }; "autofocus": { "alias": "autofocus"; "required": false; }; "clearInput": { "alias": "clearInput"; "required": false; }; "clearInputIcon": { "alias": "clearInputIcon"; "required": false; }; "clearOnEdit": { "alias": "clearOnEdit"; "required": false; }; "color": { "alias": "color"; "required": false; }; "counter": { "alias": "counter"; "required": false; }; "counterFormatter": { "alias": "counterFormatter"; "required": false; }; "debounce": { "alias": "debounce"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "enterkeyhint": { "alias": "enterkeyhint"; "required": false; }; "errorText": { "alias": "errorText"; "required": false; }; "fill": { "alias": "fill"; "required": false; }; "helperText": { "alias": "helperText"; "required": false; }; "inputmode": { "alias": "inputmode"; "required": false; }; "label": { "alias": "label"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "max": { "alias": "max"; "required": false; }; "maxlength": { "alias": "maxlength"; "required": false; }; "min": { "alias": "min"; "required": false; }; "minlength": { "alias": "minlength"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "name": { "alias": "name"; "required": false; }; "pattern": { "alias": "pattern"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "required": { "alias": "required"; "required": false; }; "shape": { "alias": "shape"; "required": false; }; "spellcheck": { "alias": "spellcheck"; "required": false; }; "step": { "alias": "step"; "required": false; }; "type": { "alias": "type"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonInput extends Components.IonInput {
    /**
     * The `ionInput` event is fired each time the user modifies the input's value.
  Unlike the `ionChange` event, the `ionInput` event is fired for each alteration
  to the input's value. This typically happens for each keystroke as the user types.
  
  For elements that accept text input (`type=text`, `type=tel`, etc.), the interface
  is [`InputEvent`](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent); for others,
  the interface is [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event). If
  the input is cleared on edit, the type is `null`.
     */
    ionInput: EventEmitter<CustomEvent<IIonInputInputInputEventDetail>>;
    /**
     * The `ionChange` event is fired when the user modifies the input's value.
  Unlike the `ionInput` event, the `ionChange` event is only fired when changes
  are committed, not as the user types.
  
  Depending on the way the users interacts with the element, the `ionChange`
  event fires at a different moment:
  - When the user commits the change explicitly (e.g. by selecting a date
  from a date picker for `<ion-input type="date">`, pressing the "Enter" key, etc.).
  - When the element loses focus after its value has changed: for elements
  where the user's interaction is typing.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonInputInputChangeEventDetail>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<FocusEvent>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<FocusEvent>>;
}
export declare class IonInputPasswordToggle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInputPasswordToggle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInputPasswordToggle, "ion-input-password-toggle", never, { "color": { "alias": "color"; "required": false; }; "hideIcon": { "alias": "hideIcon"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "showIcon": { "alias": "showIcon"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonInputPasswordToggle extends Components.IonInputPasswordToggle {
}
export declare class IonItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItem, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItem, "ion-item", never, { "button": { "alias": "button"; "required": false; }; "color": { "alias": "color"; "required": false; }; "detail": { "alias": "detail"; "required": false; }; "detailIcon": { "alias": "detailIcon"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "href": { "alias": "href"; "required": false; }; "lines": { "alias": "lines"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; "target": { "alias": "target"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonItem extends Components.IonItem {
}
export declare class IonItemDivider {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemDivider, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemDivider, "ion-item-divider", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "sticky": { "alias": "sticky"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonItemDivider extends Components.IonItemDivider {
}
export declare class IonItemGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemGroup, "ion-item-group", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonItemGroup extends Components.IonItemGroup {
}
export declare class IonItemOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemOption, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemOption, "ion-item-option", never, { "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "expandable": { "alias": "expandable"; "required": false; }; "href": { "alias": "href"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "target": { "alias": "target"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonItemOption extends Components.IonItemOption {
}
export declare class IonItemOptions {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemOptions, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemOptions, "ion-item-options", never, { "side": { "alias": "side"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonItemOptions extends Components.IonItemOptions {
    /**
     * Emitted when the item has been fully swiped.
     */
    ionSwipe: EventEmitter<CustomEvent<any>>;
}
export declare class IonItemSliding {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemSliding, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemSliding, "ion-item-sliding", never, { "disabled": { "alias": "disabled"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonItemSliding extends Components.IonItemSliding {
    /**
     * Emitted when the sliding position changes.
     */
    ionDrag: EventEmitter<CustomEvent<any>>;
}
export declare class IonLabel {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonLabel, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonLabel, "ion-label", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "position": { "alias": "position"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonLabel extends Components.IonLabel {
}
export declare class IonList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonList, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonList, "ion-list", never, { "inset": { "alias": "inset"; "required": false; }; "lines": { "alias": "lines"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonList extends Components.IonList {
}
export declare class IonListHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonListHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonListHeader, "ion-list-header", never, { "color": { "alias": "color"; "required": false; }; "lines": { "alias": "lines"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonListHeader extends Components.IonListHeader {
}
export declare class IonLoading {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonLoading, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonLoading, "ion-loading", never, { "animated": { "alias": "animated"; "required": false; }; "backdropDismiss": { "alias": "backdropDismiss"; "required": false; }; "cssClass": { "alias": "cssClass"; "required": false; }; "duration": { "alias": "duration"; "required": false; }; "enterAnimation": { "alias": "enterAnimation"; "required": false; }; "htmlAttributes": { "alias": "htmlAttributes"; "required": false; }; "isOpen": { "alias": "isOpen"; "required": false; }; "keyboardClose": { "alias": "keyboardClose"; "required": false; }; "leaveAnimation": { "alias": "leaveAnimation"; "required": false; }; "message": { "alias": "message"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "showBackdrop": { "alias": "showBackdrop"; "required": false; }; "spinner": { "alias": "spinner"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; "trigger": { "alias": "trigger"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonLoading extends Components.IonLoading {
    /**
     * Emitted after the loading has presented.
     */
    ionLoadingDidPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the loading has presented.
     */
    ionLoadingWillPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the loading has dismissed.
     */
    ionLoadingWillDismiss: EventEmitter<CustomEvent<IIonLoadingOverlayEventDetail>>;
    /**
     * Emitted after the loading has dismissed.
     */
    ionLoadingDidDismiss: EventEmitter<CustomEvent<IIonLoadingOverlayEventDetail>>;
    /**
     * Emitted after the loading indicator has presented.
  Shorthand for ionLoadingWillDismiss.
     */
    didPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the loading indicator has presented.
  Shorthand for ionLoadingWillPresent.
     */
    willPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the loading indicator has dismissed.
  Shorthand for ionLoadingWillDismiss.
     */
    willDismiss: EventEmitter<CustomEvent<IIonLoadingOverlayEventDetail>>;
    /**
     * Emitted after the loading indicator has dismissed.
  Shorthand for ionLoadingDidDismiss.
     */
    didDismiss: EventEmitter<CustomEvent<IIonLoadingOverlayEventDetail>>;
}
export declare class IonMenu {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenu, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenu, "ion-menu", never, { "contentId": { "alias": "contentId"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "maxEdgeStart": { "alias": "maxEdgeStart"; "required": false; }; "menuId": { "alias": "menuId"; "required": false; }; "side": { "alias": "side"; "required": false; }; "swipeGesture": { "alias": "swipeGesture"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonMenu extends Components.IonMenu {
    /**
     * Emitted when the menu is about to be opened.
     */
    ionWillOpen: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the menu is about to be closed.
     */
    ionWillClose: EventEmitter<CustomEvent<IIonMenuMenuCloseEventDetail>>;
    /**
     * Emitted when the menu is open.
     */
    ionDidOpen: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the menu is closed.
     */
    ionDidClose: EventEmitter<CustomEvent<IIonMenuMenuCloseEventDetail>>;
}
export declare class IonMenuButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenuButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenuButton, "ion-menu-button", never, { "autoHide": { "alias": "autoHide"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "menu": { "alias": "menu"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonMenuButton extends Components.IonMenuButton {
}
export declare class IonMenuToggle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenuToggle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenuToggle, "ion-menu-toggle", never, { "autoHide": { "alias": "autoHide"; "required": false; }; "menu": { "alias": "menu"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonMenuToggle extends Components.IonMenuToggle {
}
export declare class IonNavLink {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonNavLink, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonNavLink, "ion-nav-link", never, { "component": { "alias": "component"; "required": false; }; "componentProps": { "alias": "componentProps"; "required": false; }; "routerAnimation": { "alias": "routerAnimation"; "required": false; }; "routerDirection": { "alias": "routerDirection"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonNavLink extends Components.IonNavLink {
}
export declare class IonNote {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonNote, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonNote, "ion-note", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonNote extends Components.IonNote {
}
export declare class IonPicker {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonPicker, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonPicker, "ion-picker", never, { "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonPicker extends Components.IonPicker {
}
export declare class IonPickerColumn {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonPickerColumn, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonPickerColumn, "ion-picker-column", never, { "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonPickerColumn extends Components.IonPickerColumn {
    /**
     * Emitted when the value has changed.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonPickerColumnPickerColumnChangeEventDetail>>;
}
export declare class IonPickerColumnOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonPickerColumnOption, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonPickerColumnOption, "ion-picker-column-option", never, { "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonPickerColumnOption extends Components.IonPickerColumnOption {
}
export declare class IonPickerLegacy {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonPickerLegacy, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonPickerLegacy, "ion-picker-legacy", never, { "animated": { "alias": "animated"; "required": false; }; "backdropDismiss": { "alias": "backdropDismiss"; "required": false; }; "buttons": { "alias": "buttons"; "required": false; }; "columns": { "alias": "columns"; "required": false; }; "cssClass": { "alias": "cssClass"; "required": false; }; "duration": { "alias": "duration"; "required": false; }; "enterAnimation": { "alias": "enterAnimation"; "required": false; }; "htmlAttributes": { "alias": "htmlAttributes"; "required": false; }; "isOpen": { "alias": "isOpen"; "required": false; }; "keyboardClose": { "alias": "keyboardClose"; "required": false; }; "leaveAnimation": { "alias": "leaveAnimation"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "showBackdrop": { "alias": "showBackdrop"; "required": false; }; "trigger": { "alias": "trigger"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonPickerLegacy extends Components.IonPickerLegacy {
    /**
     * Emitted after the picker has presented.
     */
    ionPickerDidPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the picker has presented.
     */
    ionPickerWillPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the picker has dismissed.
     */
    ionPickerWillDismiss: EventEmitter<CustomEvent<IIonPickerLegacyOverlayEventDetail>>;
    /**
     * Emitted after the picker has dismissed.
     */
    ionPickerDidDismiss: EventEmitter<CustomEvent<IIonPickerLegacyOverlayEventDetail>>;
    /**
     * Emitted after the picker has presented.
  Shorthand for ionPickerWillDismiss.
     */
    didPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the picker has presented.
  Shorthand for ionPickerWillPresent.
     */
    willPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the picker has dismissed.
  Shorthand for ionPickerWillDismiss.
     */
    willDismiss: EventEmitter<CustomEvent<IIonPickerLegacyOverlayEventDetail>>;
    /**
     * Emitted after the picker has dismissed.
  Shorthand for ionPickerDidDismiss.
     */
    didDismiss: EventEmitter<CustomEvent<IIonPickerLegacyOverlayEventDetail>>;
}
export declare class IonProgressBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonProgressBar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonProgressBar, "ion-progress-bar", never, { "buffer": { "alias": "buffer"; "required": false; }; "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "reversed": { "alias": "reversed"; "required": false; }; "type": { "alias": "type"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonProgressBar extends Components.IonProgressBar {
}
export declare class IonRadio {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRadio, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRadio, "ion-radio", never, { "alignment": { "alias": "alignment"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "justify": { "alias": "justify"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRadio extends Components.IonRadio {
    /**
     * Emitted when the radio button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the radio button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonRadioGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRadioGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRadioGroup, "ion-radio-group", never, { "allowEmptySelection": { "alias": "allowEmptySelection"; "required": false; }; "compareWith": { "alias": "compareWith"; "required": false; }; "name": { "alias": "name"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRadioGroup extends Components.IonRadioGroup {
    /**
     * Emitted when the value has changed.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonRadioGroupRadioGroupChangeEventDetail>>;
}
export declare class IonRange {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRange, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRange, "ion-range", never, { "activeBarStart": { "alias": "activeBarStart"; "required": false; }; "color": { "alias": "color"; "required": false; }; "debounce": { "alias": "debounce"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "dualKnobs": { "alias": "dualKnobs"; "required": false; }; "label": { "alias": "label"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "max": { "alias": "max"; "required": false; }; "min": { "alias": "min"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "pin": { "alias": "pin"; "required": false; }; "pinFormatter": { "alias": "pinFormatter"; "required": false; }; "snaps": { "alias": "snaps"; "required": false; }; "step": { "alias": "step"; "required": false; }; "ticks": { "alias": "ticks"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRange extends Components.IonRange {
    /**
     * The `ionChange` event is fired for `<ion-range>` elements when the user
  modifies the element's value:
  - When the user releases the knob after dragging;
  - When the user moves the knob with keyboard arrows
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonRangeRangeChangeEventDetail>>;
    /**
     * The `ionInput` event is fired for `<ion-range>` elements when the value
  is modified. Unlike `ionChange`, `ionInput` is fired continuously
  while the user is dragging the knob.
     */
    ionInput: EventEmitter<CustomEvent<IIonRangeRangeChangeEventDetail>>;
    /**
     * Emitted when the range has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the range loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user starts moving the range knob, whether through
  mouse drag, touch gesture, or keyboard interaction.
     */
    ionKnobMoveStart: EventEmitter<CustomEvent<IIonRangeRangeKnobMoveStartEventDetail>>;
    /**
     * Emitted when the user finishes moving the range knob, whether through
  mouse drag, touch gesture, or keyboard interaction.
     */
    ionKnobMoveEnd: EventEmitter<CustomEvent<IIonRangeRangeKnobMoveEndEventDetail>>;
}
export declare class IonRefresher {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRefresher, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRefresher, "ion-refresher", never, { "closeDuration": { "alias": "closeDuration"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "pullFactor": { "alias": "pullFactor"; "required": false; }; "pullMax": { "alias": "pullMax"; "required": false; }; "pullMin": { "alias": "pullMin"; "required": false; }; "snapbackDuration": { "alias": "snapbackDuration"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRefresher extends Components.IonRefresher {
    /**
     * Emitted when the user lets go of the content and has pulled down
  further than the `pullMin` or pulls the content down and exceeds the pullMax.
  Updates the refresher state to `refreshing`. The `complete()` method should be
  called when the async operation has completed.
     */
    ionRefresh: EventEmitter<CustomEvent<IIonRefresherRefresherEventDetail>>;
    /**
     * Emitted while the user is pulling down the content and exposing the refresher.
     */
    ionPull: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user begins to start pulling down.
     */
    ionStart: EventEmitter<CustomEvent<void>>;
}
export declare class IonRefresherContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRefresherContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRefresherContent, "ion-refresher-content", never, { "pullingIcon": { "alias": "pullingIcon"; "required": false; }; "pullingText": { "alias": "pullingText"; "required": false; }; "refreshingSpinner": { "alias": "refreshingSpinner"; "required": false; }; "refreshingText": { "alias": "refreshingText"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRefresherContent extends Components.IonRefresherContent {
}
export declare class IonReorder {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonReorder, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonReorder, "ion-reorder", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonReorder extends Components.IonReorder {
}
export declare class IonReorderGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonReorderGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonReorderGroup, "ion-reorder-group", never, { "disabled": { "alias": "disabled"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonReorderGroup extends Components.IonReorderGroup {
    /**
     * Event that needs to be listened to in order to complete the reorder action.
  Once the event has been emitted, the `complete()` method then needs
  to be called in order to finalize the reorder action.
     */
    ionItemReorder: EventEmitter<CustomEvent<IIonReorderGroupItemReorderEventDetail>>;
}
export declare class IonRippleEffect {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRippleEffect, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRippleEffect, "ion-ripple-effect", never, { "type": { "alias": "type"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonRippleEffect extends Components.IonRippleEffect {
}
export declare class IonRow {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRow, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRow, "ion-row", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonRow extends Components.IonRow {
}
export declare class IonSearchbar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSearchbar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSearchbar, "ion-searchbar", never, { "animated": { "alias": "animated"; "required": false; }; "autocapitalize": { "alias": "autocapitalize"; "required": false; }; "autocomplete": { "alias": "autocomplete"; "required": false; }; "autocorrect": { "alias": "autocorrect"; "required": false; }; "cancelButtonIcon": { "alias": "cancelButtonIcon"; "required": false; }; "cancelButtonText": { "alias": "cancelButtonText"; "required": false; }; "clearIcon": { "alias": "clearIcon"; "required": false; }; "color": { "alias": "color"; "required": false; }; "debounce": { "alias": "debounce"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "enterkeyhint": { "alias": "enterkeyhint"; "required": false; }; "inputmode": { "alias": "inputmode"; "required": false; }; "maxlength": { "alias": "maxlength"; "required": false; }; "minlength": { "alias": "minlength"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "searchIcon": { "alias": "searchIcon"; "required": false; }; "showCancelButton": { "alias": "showCancelButton"; "required": false; }; "showClearButton": { "alias": "showClearButton"; "required": false; }; "spellcheck": { "alias": "spellcheck"; "required": false; }; "type": { "alias": "type"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSearchbar extends Components.IonSearchbar {
    /**
     * Emitted when the `value` of the `ion-searchbar` element has changed.
     */
    ionInput: EventEmitter<CustomEvent<IIonSearchbarSearchbarInputEventDetail>>;
    /**
     * The `ionChange` event is fired for `<ion-searchbar>` elements when the user
  modifies the element's value. Unlike the `ionInput` event, the `ionChange`
  event is not necessarily fired for each alteration to an element's value.
  
  The `ionChange` event is fired when the value has been committed
  by the user. This can happen when the element loses focus or
  when the "Enter" key is pressed. `ionChange` can also fire
  when clicking the clear or cancel buttons.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonSearchbarSearchbarChangeEventDetail>>;
    /**
     * Emitted when the cancel button is clicked.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the clear input button is clicked.
     */
    ionClear: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
}
export declare class IonSegment {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegment, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegment, "ion-segment", never, { "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "scrollable": { "alias": "scrollable"; "required": false; }; "selectOnFocus": { "alias": "selectOnFocus"; "required": false; }; "swipeGesture": { "alias": "swipeGesture"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSegment extends Components.IonSegment {
    /**
     * Emitted when the value property has changed and any dragging pointer has been released from `ion-segment`.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonSegmentSegmentChangeEventDetail>>;
}
export declare class IonSegmentButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegmentButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegmentButton, "ion-segment-button", never, { "contentId": { "alias": "contentId"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "layout": { "alias": "layout"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "type": { "alias": "type"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSegmentButton extends Components.IonSegmentButton {
}
export declare class IonSegmentContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegmentContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegmentContent, "ion-segment-content", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonSegmentContent extends Components.IonSegmentContent {
}
export declare class IonSegmentView {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegmentView, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegmentView, "ion-segment-view", never, { "disabled": { "alias": "disabled"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSegmentView extends Components.IonSegmentView {
    /**
     * Emitted when the segment view is scrolled.
     */
    ionSegmentViewScroll: EventEmitter<CustomEvent<IIonSegmentViewSegmentViewScrollEvent>>;
}
export declare class IonSelect {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSelect, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSelect, "ion-select", never, { "cancelText": { "alias": "cancelText"; "required": false; }; "color": { "alias": "color"; "required": false; }; "compareWith": { "alias": "compareWith"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "expandedIcon": { "alias": "expandedIcon"; "required": false; }; "fill": { "alias": "fill"; "required": false; }; "interface": { "alias": "interface"; "required": false; }; "interfaceOptions": { "alias": "interfaceOptions"; "required": false; }; "justify": { "alias": "justify"; "required": false; }; "label": { "alias": "label"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "name": { "alias": "name"; "required": false; }; "okText": { "alias": "okText"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "selectedText": { "alias": "selectedText"; "required": false; }; "shape": { "alias": "shape"; "required": false; }; "toggleIcon": { "alias": "toggleIcon"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSelect extends Components.IonSelect {
    /**
     * Emitted when the value has changed.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonSelectSelectChangeEventDetail>>;
    /**
     * Emitted when the selection is cancelled.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the overlay is dismissed.
     */
    ionDismiss: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the select has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the select loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonSelectModal {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSelectModal, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSelectModal, "ion-select-modal", never, { "header": { "alias": "header"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "options": { "alias": "options"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSelectModal extends Components.IonSelectModal {
}
export declare class IonSelectOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSelectOption, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSelectOption, "ion-select-option", never, { "disabled": { "alias": "disabled"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSelectOption extends Components.IonSelectOption {
}
export declare class IonSkeletonText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSkeletonText, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSkeletonText, "ion-skeleton-text", never, { "animated": { "alias": "animated"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSkeletonText extends Components.IonSkeletonText {
}
export declare class IonSpinner {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSpinner, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSpinner, "ion-spinner", never, { "color": { "alias": "color"; "required": false; }; "duration": { "alias": "duration"; "required": false; }; "name": { "alias": "name"; "required": false; }; "paused": { "alias": "paused"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSpinner extends Components.IonSpinner {
}
export declare class IonSplitPane {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSplitPane, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSplitPane, "ion-split-pane", never, { "contentId": { "alias": "contentId"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "when": { "alias": "when"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonSplitPane extends Components.IonSplitPane {
    /**
     * Expression to be called when the split-pane visibility has changed
     */
    ionSplitPaneVisible: EventEmitter<CustomEvent<{
        visible: boolean;
    }>>;
}
export declare class IonTab {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTab, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTab, "ion-tab", never, { "component": { "alias": "component"; "required": false; }; "tab": { "alias": "tab"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonTab extends Components.IonTab {
}
export declare class IonTabBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTabBar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTabBar, "ion-tab-bar", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "selectedTab": { "alias": "selectedTab"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonTabBar extends Components.IonTabBar {
}
export declare class IonTabButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTabButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTabButton, "ion-tab-button", never, { "disabled": { "alias": "disabled"; "required": false; }; "download": { "alias": "download"; "required": false; }; "href": { "alias": "href"; "required": false; }; "layout": { "alias": "layout"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "rel": { "alias": "rel"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "tab": { "alias": "tab"; "required": false; }; "target": { "alias": "target"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonTabButton extends Components.IonTabButton {
}
export declare class IonText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonText, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonText, "ion-text", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonText extends Components.IonText {
}
export declare class IonTextarea {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTextarea, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTextarea, "ion-textarea", never, { "autoGrow": { "alias": "autoGrow"; "required": false; }; "autocapitalize": { "alias": "autocapitalize"; "required": false; }; "autofocus": { "alias": "autofocus"; "required": false; }; "clearOnEdit": { "alias": "clearOnEdit"; "required": false; }; "color": { "alias": "color"; "required": false; }; "cols": { "alias": "cols"; "required": false; }; "counter": { "alias": "counter"; "required": false; }; "counterFormatter": { "alias": "counterFormatter"; "required": false; }; "debounce": { "alias": "debounce"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "enterkeyhint": { "alias": "enterkeyhint"; "required": false; }; "errorText": { "alias": "errorText"; "required": false; }; "fill": { "alias": "fill"; "required": false; }; "helperText": { "alias": "helperText"; "required": false; }; "inputmode": { "alias": "inputmode"; "required": false; }; "label": { "alias": "label"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "maxlength": { "alias": "maxlength"; "required": false; }; "minlength": { "alias": "minlength"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "required": { "alias": "required"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "shape": { "alias": "shape"; "required": false; }; "spellcheck": { "alias": "spellcheck"; "required": false; }; "value": { "alias": "value"; "required": false; }; "wrap": { "alias": "wrap"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonTextarea extends Components.IonTextarea {
    /**
     * The `ionChange` event is fired when the user modifies the textarea's value.
  Unlike the `ionInput` event, the `ionChange` event is fired when
  the element loses focus after its value has been modified.
  
  This event will not emit when programmatically setting the `value` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonTextareaTextareaChangeEventDetail>>;
    /**
     * The `ionInput` event is fired each time the user modifies the textarea's value.
  Unlike the `ionChange` event, the `ionInput` event is fired for each alteration
  to the textarea's value. This typically happens for each keystroke as the user types.
  
  When `clearOnEdit` is enabled, the `ionInput` event will be fired when
  the user clears the textarea by performing a keydown event.
     */
    ionInput: EventEmitter<CustomEvent<IIonTextareaTextareaInputEventDetail>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<FocusEvent>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<FocusEvent>>;
}
export declare class IonThumbnail {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonThumbnail, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonThumbnail, "ion-thumbnail", never, {}, {}, never, ["*"], false, never>;
}
export declare interface IonThumbnail extends Components.IonThumbnail {
}
export declare class IonTitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTitle, "ion-title", never, { "color": { "alias": "color"; "required": false; }; "size": { "alias": "size"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonTitle extends Components.IonTitle {
}
export declare class IonToast {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonToast, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonToast, "ion-toast", never, { "animated": { "alias": "animated"; "required": false; }; "buttons": { "alias": "buttons"; "required": false; }; "color": { "alias": "color"; "required": false; }; "cssClass": { "alias": "cssClass"; "required": false; }; "duration": { "alias": "duration"; "required": false; }; "enterAnimation": { "alias": "enterAnimation"; "required": false; }; "header": { "alias": "header"; "required": false; }; "htmlAttributes": { "alias": "htmlAttributes"; "required": false; }; "icon": { "alias": "icon"; "required": false; }; "isOpen": { "alias": "isOpen"; "required": false; }; "keyboardClose": { "alias": "keyboardClose"; "required": false; }; "layout": { "alias": "layout"; "required": false; }; "leaveAnimation": { "alias": "leaveAnimation"; "required": false; }; "message": { "alias": "message"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "position": { "alias": "position"; "required": false; }; "positionAnchor": { "alias": "positionAnchor"; "required": false; }; "swipeGesture": { "alias": "swipeGesture"; "required": false; }; "translucent": { "alias": "translucent"; "required": false; }; "trigger": { "alias": "trigger"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonToast extends Components.IonToast {
    /**
     * Emitted after the toast has presented.
     */
    ionToastDidPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the toast has presented.
     */
    ionToastWillPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the toast has dismissed.
     */
    ionToastWillDismiss: EventEmitter<CustomEvent<IIonToastOverlayEventDetail>>;
    /**
     * Emitted after the toast has dismissed.
     */
    ionToastDidDismiss: EventEmitter<CustomEvent<IIonToastOverlayEventDetail>>;
    /**
     * Emitted after the toast has presented.
  Shorthand for ionToastWillDismiss.
     */
    didPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the toast has presented.
  Shorthand for ionToastWillPresent.
     */
    willPresent: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the toast has dismissed.
  Shorthand for ionToastWillDismiss.
     */
    willDismiss: EventEmitter<CustomEvent<IIonToastOverlayEventDetail>>;
    /**
     * Emitted after the toast has dismissed.
  Shorthand for ionToastDidDismiss.
     */
    didDismiss: EventEmitter<CustomEvent<IIonToastOverlayEventDetail>>;
}
export declare class IonToggle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonToggle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonToggle, "ion-toggle", never, { "alignment": { "alias": "alignment"; "required": false; }; "checked": { "alias": "checked"; "required": false; }; "color": { "alias": "color"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "enableOnOffLabels": { "alias": "enableOnOffLabels"; "required": false; }; "justify": { "alias": "justify"; "required": false; }; "labelPlacement": { "alias": "labelPlacement"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "name": { "alias": "name"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonToggle extends Components.IonToggle {
    /**
     * Emitted when the user switches the toggle on or off.
  
  This event will not emit when programmatically setting the `checked` property.
     */
    ionChange: EventEmitter<CustomEvent<IIonToggleToggleChangeEventDetail>>;
    /**
     * Emitted when the toggle has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the toggle loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonToolbar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonToolbar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonToolbar, "ion-toolbar", never, { "color": { "alias": "color"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; }, {}, never, ["*"], false, never>;
}
export declare interface IonToolbar extends Components.IonToolbar {
}
